import os
import hashlib
import time
import re
import pdfkit
from flask import Flask, render_template, request, send_file
import subprocess
import xml.dom.minidom
from staticAnalyst.cert_analysis import cert_info
from staticAnalyst.analysis_permission import (
    manifest_premission
)
from staticAnalyst.analysis_manifest import(
    manifest_data, get_exported
)
from staticAnalyst.android_manifest_desc import MANIFEST_DESC
from staticAnalyst.dvm_permissions import DVM_PERMISSIONS
app = Flask(__name__)

# Đường dẫn tới thư mục lưu trữ các tệp được tải lên
UPLOAD_FOLDER = 'uploads'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
DECOMPILED_FOLDER = 'decompiled'
app.config['DECOMPILED_FOLDER'] = DECOMPILED_FOLDER
if not os.path.exists(DECOMPILED_FOLDER):
    os.makedirs(DECOMPILED_FOLDER)
FULL_FOLDER = 'pull'
app.config['PULL_FOLDER'] = FULL_FOLDER
if not os.path.exists(FULL_FOLDER):
    os.makedirs(FULL_FOLDER)
RESOURCE_FOLDER = 'resources'
PWD_PATH=os.getcwd()

def calculate_md5(file_path):
    md5_hash = hashlib.md5()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            md5_hash.update(byte_block)
    return md5_hash.hexdigest()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return "No file part"

    file = request.files['file']
    if file.filename == '':
        return "No selected file"

    file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
    file.save(file_path)

    # decomplie by command jadx
    filename_without_extension = os.path.splitext(file.filename)[0]
    output_dir = os.path.join(app.config['DECOMPILED_FOLDER'])+"\\"+filename_without_extension
    decompile_command = f'jadx -d {output_dir} {file_path}'
    subprocess.run(decompile_command, shell=True)
    print("decom thành công")

    # Tính toán kích thước của tệp (đơn vị byte)
    file_size_bytes = os.path.getsize(file_path)

    # Chuyển đổi kích thước sang đơn vị Megabyte (MB)
    file_size_mb = file_size_bytes / (1024 * 1024)

    # Làm tròn kết quả đến 2 chữ số sau dấu phẩy
    file_size_mb = round(file_size_mb, 2)

    # Tính toán giá trị MD5 của tệp
    md5_hash = calculate_md5(file_path)
    # show sign cer
    path_sign_cer=os.path.join(PWD_PATH, DECOMPILED_FOLDER, filename_without_extension,RESOURCE_FOLDER)
    file_path_apk=os.path.join(PWD_PATH,UPLOAD_FOLDER,file.filename)
    print(path_sign_cer)
    print(file_path_apk)
    certificate_data=cert_info(path_sign_cer,file_path_apk)

    
    # Đọc nội dung tệp AndroidManifest.xml và tạo đối tượng XML DOM
    path_mainifest=os.path.join(PWD_PATH, DECOMPILED_FOLDER, filename_without_extension,RESOURCE_FOLDER,"AndroidManifest.xml")

    with open(path_mainifest, "r") as manifest_file:
        xml_content = manifest_file.read()
        mfxml = xml.dom.minidom.parseString(xml_content)
    #PERMISSION Analyst
    manifest_permission=manifest_premission(mfxml,DVM_PERMISSIONS)

    # Application analyst
    manifest_application=manifest_data(mfxml,MANIFEST_DESC)
    # Exported analyst
    manifest_exported=get_exported(mfxml)

    # Xuất report tạm thời
    rendered_html = render_template('file_info.html', 
                           filename=file.filename ,data_cert=certificate_data, 
                           data_permission=manifest_permission , data_application=manifest_application
                           , data_exported=manifest_exported,
                           size=file_size_mb, md5=md5_hash)


    # Lưu nội dung vào một tệp HTML tạm thời
    with open('temp.html', 'w', encoding='utf-8') as f:
        f.write(rendered_html)
    # Chuyển đổi tệp HTML thành PDF
    pdfkit.from_file('temp.html', 'report.pdf')
    #end

    return render_template('file_info.html', 
                           filename=file.filename ,data_cert=certificate_data, 
                           data_permission=manifest_permission , data_application=manifest_application
                           , data_exported=manifest_exported,
                           size=file_size_mb, md5=md5_hash)
# Xuất report
@app.route('/download')
def download_file():
    file='report.pdf'
    file_path = os.path.join(PWD_PATH,file)
    # Trả về tệp tin tải xuống
    return send_file(file_path, as_attachment=True)
#End
#===========================================
# Dynamic Analyst

#activity check
@app.route('/dynamic', methods=['GET', 'POST'])
def dynamic():
    return render_template('dynamic.html')
@app.route('/activity_check', methods=['GET', 'POST'])
def activity_check():
    if request.method == 'POST':
        data = request.form['data']
        button_clicked = request.form['button']

        if button_clicked == 'process1':
            result = run_command_check_activity(data)
        else:
            result = "Invalid button clicked!"

        return render_template('activity_check.html', result=result, data=data)

    return render_template('activity_check.html', result='', data='')

def run_command_check_activity(data):
    command='adb shell am start -n'+data
    adb_process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for line in iter(adb_process.stdout.readline, b''):
        print(line.decode('utf-8'))
        time.sleep(1)  # Dừng 1 giây
        if("starting" in line.decode('utf-8').lower()):
            return f"Access to the activitys successfully: {data}"  
    return f"Failed : {data}"
#End

#Read file database
@app.route('/read_database', methods=['GET', 'POST'])
def database_check():
    if request.method == 'POST':
        data = request.form['data']
        data2 = request.form['data2']
        data3 = request.form['data3']
        button_clicked = request.form['button']

        if button_clicked == 'process1':
            result = get_all_file_db(data)
        if button_clicked == 'process2':
            result = process2(data,data2)
        if button_clicked == 'process3':
            result = process3(data,data2,data3)
       

        return render_template('read_database.html', result=result, data=data)

    return render_template('read_database.html', result='', data='')

def get_all_file_db(data):
    command='adb shell cd /data/data/'+data+'/databases ; ls'
    result = subprocess.check_output(command, shell=True)

        # Chuyển đổi kết quả thành chuỗi UTF-8~
    result_str = result.decode('utf-8')
    print(result_str)
    return f"List file database: {result_str}"  
    
def process2(data,data2):
    command='adb shell cd /data/data/'+data+'/databases; sqlite3 '+data2+' .table'
    result = subprocess.check_output(command, shell=True)
        # Chuyển đổi kết quả thành chuỗi UTF-8
    result_str = result.decode('utf-8')
    print(result_str)
    return f"List table name: {result_str}"
def process3(data,data2,data3):
    command="adb shell \"echo 'SELECT * FROM "+data3+";' | sqlite3 /data/data/"+data+"/databases/"+data2+"\""
    result = subprocess.check_output(command, shell=True)
        # Chuyển đổi kết quả thành chuỗi UTF-8
    result_str = result.decode('utf-8')
    print(result_str)
    return f"Data: {result_str}"

#End

#Insecure Data Storeage Check
@app.route('/read_file_data', methods=['GET', 'POST'])
def file_data_check():
    global root_dir
    pull_dir=os.path.join(PWD_PATH,app.config['PULL_FOLDER'])
    if request.method == 'POST':
        data = request.form['data']
        button_clicked = request.form['button']
        root_dir=os.path.join(pull_dir,data)    
        if button_clicked == 'process1':
            result = get_all_file_packet(data,pull_dir)
             

        return render_template('read_file_data.html', result=result, data=data)

    return render_template('read_file_data.html', result='', data='')

def get_all_file_packet(data,pull_dir):
    
    command='adb pull /data/data/'+data+'/ '+pull_dir
    result = subprocess.check_output(command, shell=True)

        # Chuyển đổi kết quả thành chuỗi UTF-8~
    result_str = result.decode('utf-8')
    print(result_str)
    if('pulled' in result_str.lower()):
        return f"Pulling data from package {data} successfully"
    else:
        return f"Pulling data from package {data} failed"

@app.route('/folder')
def show_folders():
    global root_dir
    try:
        folders = os.listdir(root_dir)
        return render_template('folder_list.html', folders=folders)

    except Exception as e:
        return f"Error accessing folder: {e}"

@app.route('/folder/<folder_name>')
def show_files_in_folder(folder_name):
    global root_dir
    try:
        folder_path = os.path.join(root_dir, folder_name)
        files = os.listdir(folder_path)
        return render_template('file_list.html', folder_name=folder_name, files=files)

    except Exception as e:
        return f"Error accessing folder: {e}"

@app.route('/folder/<folder_name>/view/<filename>')
def view_file(folder_name, filename):
    global root_dir
    try:
        file_path = os.path.join(root_dir, folder_name, filename)
        if not os.path.isfile(file_path):
            return f"File not found."

        with open(file_path, 'r') as file:
            content = file.read()

        return render_template('view_file.html', filename=filename, content=content)

    except Exception as e:
        return f"Error reading file: {e}"

@app.route('/search', methods=['GET', 'POST'])
def search_files():
    global root_dir
    try:
        if request.method == 'POST':
            search_query = request.form['search_query']

            matched_files = []
            for folder_name, _, files in os.walk(root_dir):
                for file_name in files:
                    file_path = os.path.join(folder_name, file_name)
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:  # Thêm encoding và errors
                        content = file.read()
                        if re.search(search_query, content.lower()):
                            matched_files.append((file_path, content))

            return render_template('search_result.html', search_query=search_query, matched_files=matched_files)

        return render_template('search_form.html')

    except Exception as e:
        return f"Error searching files: {e}"


#End

if __name__ == '__main__':
    app.run(debug=True)
